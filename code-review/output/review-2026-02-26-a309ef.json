{
  "filtered_findings": [
    {
      "id": "ASD-001",
      "file": "lib/store.py",
      "line_start": 337,
      "line_end": 341,
      "severity": "critical",
      "confidence": 0.95,
      "category": "race_condition",
      "source_agent": "async-data-integrity",
      "title": "Index read-modify-write race: concurrent saves overwrite each other's entries",
      "body": "Concreet scenario: twee processen roepen tegelijkertijd `heartbeat()` aan op twee verschillende sessies (A en B). Beide roepen `_save_session()` aan, die `_update_index()` aanroept. Proces 1 laadt de index (`{}`), Proces 2 laadt ook de index (`{}`). Proces 1 voegt sessie A toe en slaat op (`{A: ...}`). Proces 2 voegt sessie B toe en slaat op (`{B: ...}`). Resultaat: A is verdwenen uit de index. `list_sessions()` mist daarna sessie A volledig totdat een rebuild plaatsvindt. De `_session_lock` beschermt alleen het individuele sessie-JSON-bestand, niet `_index.json`. De index heeft geen eigen lock-mechanisme, waardoor elke read-modify-write op de index een onbeschermde critical section is.",
      "suggestion": "def _update_index(session: Session) -> None:\n    index_file = _index_path()\n    lock_file = index_file.with_suffix('.lock')\n    with open(lock_file, 'w') as lf:\n        fcntl.flock(lf, fcntl.LOCK_EX)\n        try:\n            index = _load_index()\n            index[session.session_id] = _index_entry(session)\n            _save_index(index)\n        finally:\n            fcntl.flock(lf, fcntl.LOCK_UN)",
      "requires_human_review": true,
      "filter_score": 10,
      "filter_rationale": "Concreet data-loss scenario: sessies verdwijnen uit de index bij gelijktijdige writes. De index is nieuwe functionaliteit (D1) zonder eigen lock — auteur zal dit zeker willen fixen. Directe, meetbare impact op data-integriteit.",
      "solution_ref": "SOL-2026-009",
      "resolved": true,
      "resolved_in": "4212438"
    },
    {
      "id": "ASD-002",
      "file": "lib/store.py",
      "line_start": 904,
      "line_end": 907,
      "severity": "high",
      "confidence": 0.88,
      "category": "race_condition",
      "source_agent": "async-data-integrity",
      "title": "Index removal in archive_old_sessions valt buiten session lock en is niet atomair",
      "body": "Concreet scenario: twee instanties van `archive_old_sessions` draaien tegelijkertijd (bijv. via cron en een CLI-aanroep). Instantie 1 archiveert sessie A (onder lock), verlaat de lock, en roept `_remove_from_index(A)` aan. Instantie 2 archiveert sessie B (onder lock), verlaat de lock, en roept `_remove_from_index(B)` aan. Als beide instanties hun `_load_index()` uitvoeren voordat de andere heeft opgeslagen: Instantie 1 laadt `{A, B}`, verwijdert A, slaat `{B}` op. Instantie 2 laadt `{A, B}`, verwijdert B, slaat `{A}` op. Eindresultaat: A staat nog in de index terwijl het bestand al naar `archive/` is verplaatst. `list_sessions()` probeert dan `get_session(A)` aan te roepen, vindt het bestand niet in SESSIONS_DIR, en retourneert `None` — waarna de sessie stilzwijgend wordt overgeslagen. De index is structureel inconsistent met de bestandssysteem-staat.",
      "suggestion": "# Verplaats _remove_from_index naar binnen de with _session_lock(sid) block:\nwith _session_lock(sid):\n    if not path.exists():\n        continue\n    fresh = _safe_read_json(path)\n    if fresh.get('status') != SessionStatus.COMPLETED:\n        continue\n    dst = ARCHIVE_DIR / f'{sid}.json'\n    shutil.move(str(path), str(dst))\n    _remove_from_index(sid)  # <-- binnen de lock, voor consistentie",
      "requires_human_review": true,
      "filter_score": 10,
      "filter_rationale": "Concreet scenario met structureel inconsistente index als resultaat. Nieuwe code (_remove_from_index), directe fix beschikbaar. Auteur zal dit willen fixen.",
      "solution_ref": "SOL-2026-010",
      "resolved": true,
      "resolved_in": "4212438"
    },
    {
      "id": "PRF-001",
      "file": "lib/store.py",
      "line_start": 700,
      "line_end": 707,
      "severity": "high",
      "confidence": 0.95,
      "category": "n_plus_one",
      "source_agent": "performance-reviewer",
      "title": "list_sessions leest elke session-file individueel na index-filtering — ondermijnt het index-doel",
      "body": "Na het filteren van de index op project_slug en/of status roept `list_sessions()` voor elke overeenkomende entry `get_session(sid)` aan. `get_session()` opent en parseert het volledige JSON-bestand van die sessie. De index bevat al alle velden die nodig zijn voor een overzichtsweergave (project_slug, status, intent, started_at, ended_at, last_heartbeat). Concreet: een project met 200 actieve sessies filtered via de index naar 50 resultaten, maar leest vervolgens 50 afzonderlijke bestanden. De API-overview-endpoint pollt elke 30s via `build_overview()` → `list_sessions()`. De latentie schaalt lineair met matchende sessies — precies het probleem dat de index (D1) moest oplossen. Fix: bouw `Session`-objecten rechtstreeks uit index-entries voor de standaard lijstweergave. Roep `get_session()` alleen aan als volledige sessiedata (bijv. tasks-veld) nodig is.",
      "suggestion": "for sid, entry in index.items():\n    if project_slug and entry.get('project_slug') != project_slug:\n        continue\n    if status and entry.get('status') != status:\n        continue\n    # Bouw Session direct uit de index-entry i.p.v. het bestand te openen\n    session = Session(\n        session_id=sid,\n        project_slug=entry['project_slug'],\n        status=entry['status'],\n        intent=entry.get('intent', ''),\n        started_at=entry.get('started_at'),\n        ended_at=entry.get('ended_at'),\n        last_heartbeat=entry.get('last_heartbeat'),\n    )\n    sessions.append(session)",
      "requires_human_review": true,
      "filter_score": 10,
      "filter_rationale": "Het index-doel (D1) wordt volledig ondermijnd door per entry toch het bestand te lezen. Concreet meetbare impact bij schaling. Auteur zal dit willen fixen zodra dit duidelijk is.",
      "solution_ref": null,
      "resolved": true,
      "resolved_in": "4212438"
    },
    {
      "id": "MERGED-003",
      "file": "lib/store.py",
      "line_start": 695,
      "line_end": 697,
      "severity": "medium",
      "confidence": 0.85,
      "category": "logic_error",
      "source_agent": "logic-correctness + performance-reviewer",
      "title": "Lege index niet te onderscheiden van ontbrekende index — triggert rebuild bij elke aanroep na archivering",
      "body": "In `list_sessions()` gebruikt de guard `if not index:` Python's truthiness op de dict van `_load_index()`. Een lege dict `{}` is falsy, dus wanneer de index bestaat en geldig is maar nul entries bevat (bijv. alle sessies gearchiveerd), wordt `rebuild_index()` aangeroepen bij elke `list_sessions()`-aanroep. `_load_index()` retourneert `{}` zowel bij 'bestand ontbreekt/corrupt' als bij 'bestand bestaat maar is leeg' — de code kan deze gevallen niet onderscheiden. Concreet: dashboard-overview pollt elke 30s, na archivering van alle sessies triggert elke poll een volledige `SESSIONS_DIR.glob('sess_*.json')` scan plus `_save_index()` write. Fix: check `_index_path().exists()` separaat om te bepalen of een rebuild nodig is.",
      "suggestion": "index_path = _index_path()\nif not index_path.exists():\n    index = rebuild_index()\nelse:\n    index = _load_index()\n    # _load_index logt al corrupt-gevallen; lege index is valid state",
      "requires_human_review": false,
      "filter_score": 10,
      "filter_rationale": "Concreet bug: na archivering van alle sessies triggert elke poll een onnodige rebuild. Nieuwe code (D1), duidelijke fix, auteur zal dit willen fixen. Gerapporteerd door twee agents (logic-correctness en performance-reviewer).",
      "solution_ref": null,
      "resolved": true,
      "resolved_in": "4212438"
    },
    {
      "id": "CON-001",
      "file": "tests/test_cli.py",
      "line_start": 376,
      "line_end": 386,
      "severity": "medium",
      "confidence": 0.95,
      "category": "test_isolation",
      "source_agent": "convention-checker",
      "title": "TestRebuildIndex mist _isolate_store fixture — schrijft naar echte schijf",
      "body": "De klasse `TestRebuildIndex` roept `store.create_session()` en `store._index_path().unlink()` aan zonder de store-paden te redirecten naar `tmp_path`. De projectconventie (CLAUDE.md) vereist expliciet: 'Test isolation: monkeypatch store.DASHBOARD_DIR, SESSIONS_DIR, PROJECTS_DIR, CONFIG_PATH to tmp_path'. Zonder deze fixture schrijven de tests naar de echte dashboard-directory, wat leidt tot vervuilde testdata, flaky tests bij paralleluitvoering, en mogelijke interferentie met de lokale installatie. Dit is nieuwe testcode toegevoegd voor de D1-feature (session index).",
      "suggestion": "Voeg de `_isolate_store` fixture toe aan de klasse:\n@pytest.mark.usefixtures('_isolate_store')\nclass TestRebuildIndex:\n    ...\nAlternatief: zet de test direct in de bestaande `_isolate_store`-context zoals alle andere test_cli-klassen doen.",
      "requires_human_review": false,
      "filter_score": 10,
      "filter_rationale": "Schending van expliciete projectconventie in nieuwe testcode. Schrijft naar echte schijf. Directe, duidelijke fix. Auteur zal dit willen corrigeren.",
      "solution_ref": null,
      "resolved": true,
      "resolved_in": "4212438",
      "resolved_note": "False positive — _isolate_store fixture is autouse=True, geldt automatisch voor alle testklassen"
    },
    {
      "id": "MERGED-001",
      "file": "lib/store.py",
      "line_start": 88,
      "line_end": 103,
      "severity": "medium",
      "confidence": 0.80,
      "category": "path_traversal",
      "source_agent": "security-sentinel + async-data-integrity",
      "title": "TOCTOU race tussen symlink-check en open() in _safe_read_json maakt de beveiligingscheck illusoir",
      "body": "De symlink-check (`path.is_symlink()`) en de daaropvolgende `open(path)` zijn twee aparte syscalls. Tussen deze twee aanroepen kan een aanvaller op een gedeeld filesystem de file vervangen door een symlink (symlink-swap attack). Dit maakt de check niet atomair en dus onbetrouwbaar als beveiligingsmaatregel. De `stat()` aanroep die de bestandsgrootte controleert vergroot het racevenster verder. Fix: gebruik `O_NOFOLLOW` via `os.open()` — als het pad een symlink is, gooit de kernel direct een `OSError`, zonder dat een aparte `is_symlink()`-check nodig is. Dit maakt de symlink-weigering atomair. Gerapporteerd door security-sentinel en async-data-integrity.",
      "suggestion": "import os\n\ndef _safe_read_json(path: Path) -> dict:\n    try:\n        fd = os.open(path, os.O_RDONLY | os.O_NOFOLLOW)\n    except OSError as e:\n        import errno\n        if e.errno in (errno.ELOOP, errno.EMLINK):\n            raise ValueError(f'Refusing to read symlink: {path.name}') from e\n        raise\n    size = os.fstat(fd).st_size\n    if size > MAX_JSON_FILE_SIZE:\n        os.close(fd)\n        raise ValueError(\n            f'File too large: {path.name} ({size} bytes, max {MAX_JSON_FILE_SIZE})'\n        )\n    with os.fdopen(fd) as f:\n        return json.load(f)",
      "requires_human_review": false,
      "filter_score": 8,
      "filter_rationale": "De symlink-beveiliging in de nieuwe _safe_read_json (C5) is niet atomair en daarmee illusoir. Concreet exploit-patroon. Fix met O_NOFOLLOW is de canonieke oplossing voor dit patroon.",
      "solution_ref": "SOL-2026-004",
      "resolved": true,
      "resolved_in": "4212438"
    },
    {
      "id": "MERGED-002",
      "file": "web/app.py",
      "line_start": 48,
      "line_end": 50,
      "severity": "medium",
      "confidence": 0.85,
      "category": "information_disclosure",
      "source_agent": "security-sentinel + python-specialist",
      "title": "ValueError handler lekt interne bestandsnamen en implementatiedetails naar API-clients",
      "body": "De generieke `ValueError` exception handler geeft `str(exc)` ongefiltered terug als `error`-veld in de JSON response. `_safe_read_json()` genereert foutberichten als `\"File too large: _index.json (10485761 bytes, max 10485760)\"` en `\"Refusing to read symlink: sess_20260226T1200_ab12.json\"`. Deze strings bevatten interne bestandsnamen en implementatiedetails die niet naar ongeauthenticeerde API-clients mogen lekken. `_validate_session_id` spiegelt bovendien user-controlled input letterlijk terug. Fix: log de volledige exception intern en stuur een generieke client-message terug zonder interne details. Gerapporteerd door security-sentinel en python-specialist.",
      "suggestion": "@app.exception_handler(ValueError)\nasync def value_error_handler(request: Request, exc: ValueError):\n    # Log intern voor diagnostiek, stuur generieke boodschap naar client\n    logger.warning('ValueError on %s: %s', request.url.path, exc)\n    return _error_response('Invalid request', 'VALIDATION_ERROR', 400)",
      "requires_human_review": false,
      "filter_score": 8,
      "filter_rationale": "Nieuwe exception handler (C4) lekt interne implementatiedetails via error messages. Concrete voorbeelden van wat lekt. Fix is duidelijk en consistent met security hardening intent van de PR.",
      "solution_ref": null,
      "resolved": true,
      "resolved_in": "4212438"
    }
  ],
  "filter_stats": {
    "received": 14,
    "hard_excluded": 0,
    "duplicates_merged": 3,
    "confidence_filtered": 2,
    "score_filtered": 4,
    "max_capped": 2,
    "final_count": 7
  },
  "verdict": "approved",
  "verdict_rationale": "Alle 7 findings zijn opgelost in commit 4212438. Index locking, O_NOFOLLOW, info disclosure, N+1 query en lege-index rebuild zijn gefixt. CON-001 was false positive (autouse fixture).",
  "risk_score": 0
}

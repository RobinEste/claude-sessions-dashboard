{
  "filtered_findings": [
    {
      "id": "SEC-001",
      "file": "web/app.py",
      "line_start": 117,
      "line_end": 135,
      "severity": "medium",
      "confidence": 0.80,
      "category": "header_injection",
      "source_agent": "security-sentinel",
      "title": "HTTP response header injection via unvalidated project slug in Content-Disposition",
      "body": "In `api_export_project` wordt de `slug` path parameter zonder sanitizatie in de `Content-Disposition` header geplaatst als filename. FastAPI percent-decodeert path parameters, waardoor een URL als `/api/export/project/foo%22;%20filename=evil.exe` resulteert in `Content-Disposition: attachment; filename=\"foo\"; filename=evil.exe-sessions.md`. Dit stelt een aanvaller in staat om met percent-encoded speciale tekens arbitraire parameters in de response header te injecteren.\n\nHet session-export endpoint heeft dit probleem niet omdat `store.get_session()` `_validate_session_id()` aanroept met een strikte regex. Het project-export endpoint heeft geen equivalente guard — `list_sessions()` valideert het slug-formaat niet.\n\nExploit-scenario: Een aanvaller maakt een URL `GET /api/export/project/legit%22;%20filename%3Dmalware.exe` en deelt deze. Wanneer een slachtoffer erop klikt, suggereert de browser het bestand op te slaan als `malware.exe`, afhankelijk van de header-parsing van de browser.",
      "suggestion": "Roep `validate_project_slug(slug)` aan aan het begin van `api_export_project` (voor de `list_sessions` aanroep). De bestaande `validate_project_slug` functie in `lib/validation.py` handhaaft al veilige tekens. Alternatief: saniteer de filename direct voor het inbedden in de header door tekens buiten `[a-z0-9_-]` te verwijderen.",
      "requires_human_review": false,
      "filter_score": 10,
      "filter_rationale": "Concrete header injection met realistisch exploit-scenario via percent-encoded URL. Bestaande fix (validate_project_slug) is al aanwezig in de codebase maar niet toegepast op dit endpoint. Auteur zou dit onmiddellijk fixen.",
      "solution_ref": null,
      "resolved": false
    },
    {
      "id": "CON-001",
      "file": "lib/export.py",
      "line_start": 190,
      "line_end": 190,
      "severity": "medium",
      "confidence": 0.95,
      "category": "architecture",
      "source_agent": "convention-checker, logic-correctness",
      "title": "datetime.now() zonder UTC in export_project_json — inconsistent met codebase-patroon",
      "body": "In `lib/export.py` regel 190 wordt `datetime.now().astimezone().isoformat()` gebruikt voor de `exported_at` timestamp. Het gehele project gebruikt consequent `datetime.now(UTC)` via de `_now_iso()` helper in `store.py`. Op systemen in een niet-UTC tijdzone produceert dit een tijdstempel met lokale offset (bijv. `+01:00`) in plaats van UTC. Dit breekt geen functionaliteit, maar leidt tot inconsistente tijdstempels in geëxporteerde data en kan integraties die UTC verwachten in de war brengen.\n\nBevinding samengevoegd uit convention-checker (CON-001, confidence 0.95) en logic-correctness (LOG-001, confidence 0.80). Zelfde bestand, zelfde regel, zelfde probleem.",
      "suggestion": "Vervang `datetime.now().astimezone().isoformat()` door `datetime.now(UTC).isoformat()` consistent met het bestaande patroon. Importeer `UTC` from `datetime` zoals in `store.py`.",
      "requires_human_review": false,
      "filter_score": 9,
      "filter_rationale": "Directe inconsistentie met het vastgestelde codebase-patroon in nieuwe code. Eenvoudige fix, hoge confidence (0.95). Auteur zou dit fixen als die het wist.",
      "solution_ref": null,
      "resolved": false
    },
    {
      "id": "DUP-001",
      "file": "lib/export.py",
      "line_start": 47,
      "line_end": 55,
      "severity": "medium",
      "confidence": 0.97,
      "category": "code_duplication",
      "source_agent": "duplication-checker",
      "title": "_task_summary() gedupliceerd in lib/export.py en lib/store.py",
      "body": "`lib/export.py` introduceert een private functie `_task_summary()` (regels 47-55) die functioneel identiek is aan `_task_summary()` in `lib/store.py` (regels 1119-1127). Beide functies accepteren `list[dict]` en retourneren een dict met dezelfde vijf sleutels (`total`, `completed`, `in_progress`, `pending`, `skipped`). Het enige verschil is dat `store.py` ruwe string literals gebruikt terwijl `export.py` `TaskStatus` enum-leden gebruikt — maar omdat `TaskStatus` een `StrEnum` is, leveren beide vergelijkingen exact dezelfde runtime-waarden op.\n\nDit is precies het patroon dat SOL-2026-002 beschrijft: de fix is blijkbaar niet doorgezet naar de nieuwe `export.py` module.",
      "suggestion": "Verplaats `_task_summary()` naar `lib/models.py` (of een nieuw `lib/utils.py`), gebruik `TaskStatus` enum-leden consequent, en importeer de functie in zowel `store.py` als `export.py`. Alternatief: `export.py` kan `store._task_summary()` importeren als de module-grens dit toelaat.",
      "requires_human_review": false,
      "filter_score": 9,
      "filter_rationale": "Concrete code duplicatie in nieuwe code, hoge confidence (0.97). Matcht exact SOL-2026-002 patroon dat eerder als probleem erkend is. Toekomstige wijzigingen aan task-tellogica moeten op twee plekken doorgevoerd worden.",
      "solution_ref": "SOL-2026-002",
      "resolved": false
    },
    {
      "id": "PYT-002",
      "file": "web/app.py",
      "line_start": 117,
      "line_end": 135,
      "severity": "medium",
      "confidence": 0.95,
      "category": "endpoint_structure",
      "source_agent": "python-specialist",
      "title": "API export project-route slaat include_archived over — CLI/API feature parity ontbreekt",
      "body": "De CLI `export` command accepteert `--include-archived` en geeft dit door aan `store.list_sessions(include_archived=args.include_archived)`. De corresponderende API route `api_export_project` roept `store.list_sessions(project_slug=slug)` aan zonder `include_archived` parameter. Hierdoor is de web API niet feature-equivalent met de CLI: gearchiveerde sessies zijn niet exporteerbaar via de API, terwijl de CLI dat wel ondersteunt. Dit is een zichtbare functionaliteitsgap voor gebruikers van het web dashboard.",
      "suggestion": "Voeg een optionele query parameter toe aan het endpoint: `include_archived: bool = Query(False)` en geef deze door aan `store.list_sessions(project_slug=slug, include_archived=include_archived)`.",
      "requires_human_review": false,
      "filter_score": 10,
      "filter_rationale": "Concrete functionaliteitsontbrekenis in nieuwe code — gebruikers kunnen archived sessies niet exporteren via de API terwijl de CLI dat wel kan. Eenvoudige fix, hoge confidence (0.95). Auteur zou dit direct willen fixen.",
      "solution_ref": null,
      "resolved": false
    },
    {
      "id": "PYT-004",
      "file": "lib/export.py",
      "line_start": 209,
      "line_end": 212,
      "severity": "medium",
      "confidence": 0.85,
      "category": "fragile_string_manipulation",
      "source_agent": "python-specialist, performance-reviewer",
      "title": "Heading-shift via fragiele str.replace in export_project_markdown — correctheids- en schaalbaarheidsrisico",
      "body": "In `lib/export.py` regels 211-212 wordt heading-level shift gedaan via `session_md.replace('# Session:', '## Session:', 1)` gevolgd door `shifted.replace('\\n## ', '\\n### ')`. Dit is fragiel om twee redenen:\n\n1. **Correctheidsrisico** (python-specialist, confidence 0.80): Als `session.intent` de substring `# Session:` bevat, of als toekomstige wijzigingen in `export_session_markdown` een heading-niveau toevoegen, produceert dit stille fouten. De tweede replace heeft geen limiet en zal alle `\\n## ` occurrences in de sessie-content aanpassen, niet alleen structurele headings.\n\n2. **Schaalbaarheidsrisico** (performance-reviewer, confidence 0.85): Voor n sessies met gemiddeld m tekens per sessie is de totale replace-werk O(n×m) — een globale string scan over elke volledige sessie-markdown. Bij 50 sessies van elk 10 KB = 500 KB intermediaire string bewerkingen.\n\nBevinding samengevoegd uit python-specialist (PYT-004) en performance-reviewer (PRF-002). Hoogste severity: medium.",
      "suggestion": "Voeg een `heading_prefix` of `heading_level` parameter toe aan `export_session_markdown` (default `'#'` / `1`) zodat de caller het niveau controleert. Project-exports roepen dan `export_session_markdown(session, heading_level=2)` aan en genereren direct de juiste heading-niveaus zonder post-hoc string manipulation.",
      "requires_human_review": false,
      "filter_score": 9,
      "filter_rationale": "Fragiel patroon in nieuwe code dat stille bugs kan introduceren bij content die structureel lijkt op markdown headings. Fix is concreet en verbetert zowel correctheid als schaalbaarheid.",
      "solution_ref": null,
      "resolved": false
    },
    {
      "id": "PRF-001",
      "file": "web/app.py",
      "line_start": null,
      "line_end": null,
      "severity": "high",
      "confidence": 0.95,
      "category": "missing_pagination",
      "source_agent": "performance-reviewer",
      "title": "Geen limiet op project export endpoint — volledige dataset in memory bij grote projecten",
      "body": "`api_export_project` roept `store.list_sessions(project_slug=slug)` aan zonder enige limiet of paginering. Alle sessies van een project worden in één keer in memory geladen, geserialiseerd via `export_project_json` (inclusief `asdict()` per sessie met alle tasks, commits en events) en als één response teruggestuurd. Bij een project met honderden sessies kan dit leiden tot responses van meerdere MB's en piekgeheugengebruik dat een veelvoud is van de responsegrootte. Dit is een structureel schaalbaarheidsrisico in een endpoint zonder bovengrens.",
      "suggestion": "Voeg een `limit` en `offset` query parameter toe aan het endpoint, of voeg een expliciete `max_sessions` bovengrens toe. Voor de JSON-variant kan `StreamingResponse` het piekgeheugengebruik reduceren doordat de response niet volledig in memory gebufferd hoeft te worden voor verzending.",
      "requires_human_review": true,
      "filter_score": 7,
      "filter_rationale": "HIGH severity schaalbaarheidsrisico in nieuw endpoint zonder enige bovengrens. Realistisch scenario bij gebruik in productie met veel sessies. Fix vereist architecturele keuze (paginering vs streaming vs max-cap).",
      "solution_ref": null,
      "resolved": false
    }
  ],
  "filter_stats": {
    "received": 13,
    "hard_excluded": 2,
    "duplicates_merged": 2,
    "confidence_filtered": 3,
    "score_filtered": 2,
    "max_capped": 0,
    "final_count": 6
  },
  "verdict": "changes_requested",
  "verdict_rationale": "Een HIGH bevinding (ontbrekende paginering op project export endpoint) en een concrete header injection (SEC-001) vereisen aanpassing voor merge. Totaal 6 bevindingen waarvan 1 HIGH en 5 MEDIUM.",
  "risk_score": 40
}

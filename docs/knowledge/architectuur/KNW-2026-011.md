# KNW-2026-011: Dedicated lock voor shared derived state (index-bestanden)

## Metadata
- **Categorie:** architectuur
- **Relevantie:** hoog
- **Datum:** 2026-02-26
- **Sessie-context:** Session index (D1) en review fix voor index race condition (ASD-001)

## Inzicht

Wanneer meerdere entiteiten een gedeeld index-bestand bijwerken, is de per-entiteit lock onvoldoende. De index heeft een eigen lock nodig omdat de read-modify-write cyclus op de index een andere critical section is dan de mutatie van de individuele entiteit.

## Context

De session index (`_index.json`) wordt bijgewerkt vanuit `_save_session()`, die al onder `_session_lock(session_id)` draait. Maar twee gelijktijdige sessie-updates (A en B) nemen elk hun eigen sessie-lock — niet elkaars. Beide lezen de index, voegen hun entry toe, en schrijven terug. Resultaat: de laatst schrijvende overschrijft de entry van de ander. Een aparte `_index_lock()` met `fcntl.flock` op `_index.json.lock` lost dit op.

## Geleerd

- **Lock-granulariteit:** Per-entiteit locks beschermen individuele entiteiten, maar niet shared derived state die door meerdere entiteiten wordt gemuteerd.
- **Twee lock-niveaus:** Entiteit-lock (per sessie) + index-lock (gedeeld). De index-lock heeft een kleiner window — alleen de read-modify-write van de index zelf.
- **Nesting vermijden:** De `_index_lock` wordt binnen `_save_session` genest in `_session_lock`. Dit is veilig zolang de volgorde altijd session → index is (geen deadlocks).
- Dit patroon is analoog aan database-indexen: een row lock beschermt de row, maar index-updates hebben hun eigen interne locking.

## Toepassing

- File-based stores met index-bestanden of samenvattingsbestanden.
- Caching-lagen die een aggregate bijhouden naast individuele entries.
- Elk systeem waar meerdere onafhankelijke writers een gedeeld bestand muteren.
- Overweeg of de index uberhaupt een lock nodig heeft — als rebuilds goedkoop zijn, kan eventual consistency volstaan.

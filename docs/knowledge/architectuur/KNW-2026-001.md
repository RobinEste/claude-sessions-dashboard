# KNW-2026-001: File-based locking met fcntl.flock voor JSON stores

## Metadata
- **Categorie:** architectuur
- **Relevantie:** hoog
- **Datum:** 2026-02-23
- **Sessie-context:** Concurrency hardening voor een JSON file-based session store

## Inzicht

Bij een file-based JSON store zonder database zijn read-modify-write cycli kwetsbaar voor TOCTOU race conditions. `fcntl.flock` op een dedicated `.lock`-bestand per entiteit is het standaardpatroon voor exclusieve toegang op POSIX-systemen.

## Context

Het Claude Sessions Dashboard slaat sessie-data op als losse JSON-bestanden. Meerdere processen (CLI, heartbeat, cleanup job) kunnen tegelijkertijd dezelfde sessie muteren. Zonder locking overschrijft de laatste schrijver alle wijzigingen van de eerste.

## Geleerd

- Gebruik een apart `.lock`-bestand per entiteit, niet het databestand zelf — dit voorkomt corruptie bij gelijktijdig lezen en schrijven.
- Wrap het lock in een `@contextmanager` zodat unlock altijd plaatsvindt (ook bij exceptions).
- `fcntl.flock` werkt op file descriptors, niet op paden — het is daarom veilig om het lockbestand te openen voordat je lockt.
- Atomic write (`tempfile` + `os.replace`) beschermt tegen file-corruptie, maar NIET tegen lost updates. Je hebt beide nodig: locking voor atomiciteit, atomic write voor crash safety.
- Houd resource-zware operaties (zoals `_refresh_project_state`) buiten de lock om deadlocks te voorkomen.

## Toepassing

- Elk project met file-based state en meerdere schrijvers.
- Alternatief: SQLite met WAL mode biedt vergelijkbare garanties met minder code.
- Overweeg lock-file cleanup (`.unlink`) in het finally-block bij langdraaiende systemen.

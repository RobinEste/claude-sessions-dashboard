# KNW-2026-009: O_NOFOLLOW voor atomaire symlink-weigering zonder TOCTOU

## Metadata
- **Categorie:** security
- **Relevantie:** hoog
- **Datum:** 2026-02-26
- **Sessie-context:** Security hardening van _safe_read_json (C5) en review fix (MERGED-001)

## Inzicht

De combinatie `path.is_symlink()` + `open(path)` is inherent kwetsbaar voor TOCTOU-aanvallen: tussen de check en de open kan een aanvaller het bestand vervangen door een symlink. Gebruik `os.open(path, os.O_RDONLY | os.O_NOFOLLOW)` om de kernel atomair een symlink te laten weigeren — zonder apart te hoeven checken.

## Context

De eerste implementatie van `_safe_read_json` gebruikte `path.is_symlink()` als guard gevolgd door `open(path)`. Code review (MERGED-001) identificeerde dit als een symlink-swap attack vector: twee aparte syscalls met een racevenster ertussen. De `stat()` call voor bestandsgrootte vergrootte het window nog verder.

## Geleerd

- `O_NOFOLLOW` laat de kernel een `OSError` (errno `ELOOP` of `EMLINK`) gooien als het pad een symlink is — de check en open zijn één operatie.
- Na `os.open()` kun je `os.fstat(fd)` gebruiken voor grootte-check op de **geopende** file descriptor — niet op het pad (dat intussen kan zijn veranderd).
- Gebruik `os.fdopen(fd)` om de fd om te zetten naar een Python file object. Let op ownership: na `os.fdopen()` beheert Python de fd.
- Als je de fd moet sluiten vóór `os.fdopen()` (bijv. bij size-overschrijding), doe dat expliciet met `os.close(fd)`.

## Toepassing

- Elke functie die bestanden leest in een directory waar untrusted content kan staan.
- Configuratie-loaders die bestanden uit user-writable directories lezen.
- JSON/YAML parsers die paden accepteren van externe bronnen.
- Niet relevant op Windows (O_NOFOLLOW is POSIX-only) — daar is een alternatieve aanpak nodig.
